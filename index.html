<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carta Pergamino Sellada</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merienda:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="open-prompt">
        <div class="envelope-icon">‚úâÔ∏è</div> 
        Presiona para abrir la carta
    </div>

    <div class="parchment">
        <div class="letter-content">
            <h1>Para mi peque√±a coshita</h1>
            <p>Bueno, bizcochito lindo, chiquitico, apapachable, amoroso y muchas cosas m√°s‚Ä¶</p>
             <p>El tiempo, ese Correcaminos implacable... y yo, a veces sinti√©ndome como el Coyote en su eterna persecuci√≥n. Pero mi escepticismo ten√≠a ra√≠ces m√°s profundas: hab√≠a renunciado a la vulnerable esperanza de conectar, de creer en otro ser, porque sent√≠a que ese barco ya hab√≠a zarpado para m√≠.  Y sin embargo, en medio de esa resignaci√≥n, como si el destino me ofreciera una √∫ltima vuelta inesperada, llegaste t√∫. Quiz√°s lo m√°s importante no es atrapar el tiempo, sino descubrir que, incluso cuando has dejado de perseguir, algo o alguien valioso puede aparecer y ense√±arte una nueva forma de reformar esos "cimientos" que se daban por hechos, fijos y permanentes.</p>
             <p>A pesar de eso, me alegra y me sorprende que ya hace un a√±o te conoc√≠, y empezamos a escribir esta bonita historia. Con altos y bajos, sentimientos y desdenes ‚Äîque, a fin de cuentas, es como suele funcionar la vida: con su fr√°gil equilibrio que quienes se atreven a sostener, pueden disfrutar de los peque√±os placeres, como el querer y entregarse.</p>
             <p>Tambi√©n es cierto que me entristece que haya llegado una personita tan especial en estos momentos llenos de ruido y caos‚Ä¶ Sin embargo, todo esto forma parte de m√≠. Y as√≠ como hay malos momentos, tambi√©n hay buenos momentos, muy buenos, de hecho. Agradezco tu paciencia y tu conciencia frente a una realidad quiz√°s m√°s distinta a la de la gran mayor√≠a.</p>
             <p>Gracias por darme peque√±os fragmentos de tu ser y permitirme atesorarlos en mi presente. No s√© qu√© nos espera en el futuro, sin embargo, estoy agradecido por el presente que me ha tra√≠do hasta este puerto. Sea lo que sea que pase, lo que ya se ha escrito, nadie me lo podr√° arrebatar. Quiz√°s, con el tiempo, estas palabras se olviden‚Ä¶ pero lo que pienso y siento ahora, el tiempo no podr√° llev√°rselo. Porque le dediqu√© un espacio infinito a sentir y dejarme llevar. Y eso‚Ä¶ eso ya es otra escena m√°s que queda presente en la memoria del universo repitiendose por siempre.</p>
             <p>---</p>
             <p><em>De: Tu querido Buho ü¶âüêà</em></p>
        </div>
    </div>

    <script>
document.addEventListener('DOMContentLoaded', () => {
    const openPrompt = document.getElementById('open-prompt');
    const parchment = document.querySelector('.parchment');
    const letterContent = document.querySelector('.letter-content');

    if (openPrompt && parchment && letterContent) {
        // 1. Evento para "abrir" (mostrar) el pergamino
        openPrompt.addEventListener('click', () => {
            openPrompt.classList.add('hidden'); // Oculta el bot√≥n
            parchment.classList.add('unrolling'); // Aplica clase para mostrar pergamino (ahora sin animaci√≥n larga)

            // 2. Inicia el typewriter DESPU√âS de que el pergamino sea visible
            // Usamos setTimeout para dar tiempo al navegador a renderizar el pergamino visible
            setTimeout(() => {
                startTypewriter(letterContent); // Llama a la funci√≥n del typewriter
            }, 450); // Retraso en ms. Ajusta seg√∫n la duraci√≥n de la transici√≥n CSS (0.4s = 400ms) + peque√±o margen
        });

        // --- ELIMINADO O COMENTADO ---
        // Ya no necesitamos esperar a animationend porque no hay animaci√≥n 'unroll'
        /*
        parchment.addEventListener('animationend', () => {
            if (parchment.classList.contains('unrolling')) {
                 startTypewriter(letterContent);
            }
        }, { once: false });
        */

    } else {
        console.error("Error: Elementos necesarios (#open-prompt, .parchment o .letter-content) no encontrados.");
    }
});

// --- Funciones para el efecto Typewriter (SIN CAMBIOS) ---

async function startTypewriter(container) {
    // Selecciona todos los elementos de texto directo (h1, p)
    const elementsToAnimate = container.querySelectorAll('h1, p');
    const originalContents = [];

    // Guarda el contenido original y ASEG√öRATE de que est√©n vac√≠os inicialmente
    // Aunque el CSS los oculta, vaciarlos aqu√≠ es redundante pero seguro.
    elementsToAnimate.forEach(el => {
        originalContents.push({ element: el, html: el.innerHTML });
        el.innerHTML = ''; // Limpia el contenido por si acaso
        // ¬°IMPORTANTE! NO los hacemos visibles aqu√≠ todav√≠a.
    });

    // Recorre cada elemento
    for (const item of originalContents) {
        // === CAMBIO CLAVE ===
        // Haz visible el elemento JUSTO ANTES de empezar a escribir en √©l
        item.element.style.visibility = 'visible';

        // "Escribe" su texto esperando a que termine el anterior
        await typeText(item.element, item.html);

        // Pausa breve entre p√°rrafos (opcional)
        await new Promise(resolve => setTimeout(resolve, 200)); // 200ms de pausa
    }
}

// Funci√≥n typeText (SIN CAMBIOS - ya funciona correctamente)
function typeText(element, html) {
    return new Promise(resolve => {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        const textToType = tempDiv.textContent || tempDiv.innerText || "";
        let index = 0;
        const typingSpeed = 40; // ms por car√°cter

        element.classList.add('typing-cursor');

        function typeCharacter() {
            if (index < textToType.length) {
                element.textContent += textToType.charAt(index);
                index++;
                setTimeout(typeCharacter, typingSpeed);
            } else {
                element.innerHTML = html; // Restaura HTML original
                element.classList.remove('typing-cursor');
                resolve();
            }
        }
        typeCharacter();
    });
}
    </script>

</body>
</html>